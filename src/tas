#!/usr/bin/perl

#
# Tawas Assembler: A very basic assembler for the 'tawas' processor core
#
# by David M. Koltak  02/11/2016
#
# The MIT License (MIT)
# 
# Copyright (c) 2016 David M. Koltak
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# 

if ($#ARGV < 0)
{ die "Usage: sas input {input ...}\n  - Files assembled in left to right order\n  - Output is placed in ./irom.hex and ./dram.hex\n"; }

$PC = 0;
$DC = 0;
@Iwords = ();
@Dwords = ();

%Labels = ();
@FixUps = ();

@FileList = @ARGV;
$FilesParsed = '';

while ($#FileList >= 0)
{
  $input_filename = shift(@FileList);
  
  open(_INPUT_FILE_, "<".$input_filename) || die "ERROR: Unable to open '$input_filename' for reading.\n";
  
  $FilesParsed .= "$input_filename|";
  
  $linenum = 0;
  while (my $line = <_INPUT_FILE_>)
  {
    $linenum++;
    chomp ($line);
    $line =~ s/\/\/.*//;
    $line =~ s/^\s+//;
    
    if ($line =~ /\.include\s*\(\s*(.*)\s*\)/)
    {
      $include_file = $1;
      if (!($FilesParsed =~ /$include_file/))
      { push(@FileList, $include_file); }
      next;
    }
    
    if ($line =~ /\.org\(\s*(.*)\s*\)/)
    {
      $new_pc = parse_num($1);
      if ($PC > $new_pc)
      { die "ERROR: Cannot ORG backwards ($PC -> $new_pc) @ $input_filename:$linenum\n"; }
      $PC = $new_pc;
      next;
    }
    
    if ($line =~ /^(\w+):/)
    {
      my $label = $1;
      $line =~ s/^.*:\s*//;
      $Labels{$label} = "$PC,$DC";
    }
    
    if ($line eq '')
    { next; }
    
    if ($line =~ /\s*(ld|st|push|pop)\s*\((.+)\)\s*;\s*(ld|st|push|pop)\s*\((.+)\)\s*;/)
    {
      # ld/st, ld/st
      $i_lower = &ldst($1, $2);
      $i_upper = &ldst($3, $4);
      $i_total = (1 << 30) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*(br|rtn|icall)\s*\((.*)\)\s*;\s*(ld|st|push|pop)\s*\((.+)\)\s*;/)
    {
      # br, ld/st
      $i_lower = &ldst($3, $4);
      $i_upper = &brrtn($1, $2);
      $i_total = (13 << 28) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*(ld|st|push|pop)\s*\((.+)\)\s*;\s*(br|rtn|icall)\s*\((.*)\)\s*;/)
    {
      # br, ld/st
      $i_lower = &ldst($1, $2);
      $i_upper = &brrtn($3, $4);
      $i_total = (13 << 28) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*(call|jmp)\s*\((.+)\)\s*;\s*push\s*\(\s*[rR]6\s*\)\s*;/)
    {
      # call/jmp
      $i_total = &calljmp($1, $2);
      $i_total |= (1 << 25);
    }
    elsif ($line =~ /\s*(ld|st|push|pop)\s*\((.+)\)\s*;\s*([a-z]+)\s*\((.*)\)\s*;/)
    {
      # ls, au
      $i_lower = &au($3, $4);
      $i_upper = &ldst($1, $2);
      $i_total = (2 << 30) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*([a-z]+)\s*\((.*)\)\s*;\s*(ld|st|push|pop)\s*\((.+)\)\s*;/)
    {
      # ls, au
      $i_lower = &au($1, $2);
      $i_upper = &ldst($3, $4);
      $i_total = (2 << 30) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*(br|rtn|icall)\s*\((.*)\)\s*;\s*([a-z]+)\s*\((.*)\)\s*;/)
    {
      # br, au
      $i_lower = &au($3, $4);
      $i_upper = &brrtn($1, $2);
      $i_total = (12 << 28) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*([a-z]+)\s*\((.*)\)\s*;\s*(br|rtn|icall)\s*\((.*)\)\s*;/)
    {
      # br, au
      $i_lower = &au($1, $2);
      $i_upper = &brrtn($3, $4);
      $i_total = (12 << 28) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*([a-z]+)\s*\((.*)\)\s*;\s*([a-z]+)\s*\((.*)\)\s*;/)
    {
      # au, au
      $i_lower = &au($1, $2);
      $i_upper = &au($3, $4);
      $i_total = ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*(call|jmp)\s*\((.+)\)\s*;/)
    {
      # call/jmp
      $i_total = &calljmp($1, $2);
    }
    elsif ($line =~ /\s*(br|rtn|icall)\s*\((.*)\)\s*;/)
    {
      # br, nop
      $i_lower = 0;
      $i_upper = &brrtn($1, $2);
      $i_total = (12 << 28) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*(ldi)\s*\((.+)\)\s*;/)
    {
      # ldi
      $i_total = &ldi($1, $2);
    }
    elsif ($line =~ /\s*(nop)\s*\((.*)\)\s*;/)
    {
      # nop
      $i_total = 0xC0008000;
    }
    elsif ($line =~ /\s*(nop2)\s*\((.*)\)\s*;/)
    {
      # nop2
      $i_total = 0x00000000;
    }
    elsif ($line =~ /\s*(ld|st|push|pop)\s*\((.+)\)\s*;/)
    {
      # br, ls
      $i_lower = &ldst($1, $2);
      $i_upper = 1;
      $i_total = (13 << 28) | ($i_upper << 15) | ($i_lower);
    }
    elsif ($line =~ /\s*([a-z]+)\s*\((.*)\)\s*;/)
    {
      # br, au
      $i_lower = &au($1, $2);
      $i_upper = 1;
      $i_total = (12 << 28) | ($i_upper << 15) | ($i_lower);
    }
    else
    { die "ERROR: Invalid instruction format @ $input_filename:$linenum\n"; }
    
    #printf("---> 0x%06X : %08X\n", $PC, $i_total);
    $Iwords[$PC] = $i_total;
    $PC++;
  }
}

$Labels{".text.start"} = "0,0";
$Labels{".text.end"} = ($#Iwords + 1).",0";

$Labels{".data.start"} = "0,0";
$Labels{".data.end"} = "0,".($#Dwords + 1);
      
foreach $FixUp (@FixUps)
{
  my @spec = split(/\|/, $FixUp);
  
  if (exists $Labels{$spec[2]})
  { $label_addr = $Labels{$spec[2]}; }
  else
  { die "ERROR: Unresolved label '".$spec[2]."' @ ".$spec[3]."\n"; }
  
  if ($spec[0] eq 'br.short')
  {
    $label_addr =~ s/,.*//;
    $val = $label_addr - $spec[1];
    
    if (($val < -128) || ($val > 127))
    { die "ERROR: Relative address for *conditional* branch exceeds limit (-128,127) for label '".$spec[2]."' @ ".$spec[3]."\n"; }
    
    $Iwords[$spec[1] + 0] |= (($val & 0xFF) << 15);
  }
  elsif ($spec[0] eq 'br.long')
  {
    $label_addr =~ s/,.*//;
    $val = $label_addr - $spec[1];
    
    if (($val < -2048) || ($val > 2047))
    { die "ERROR: Relative address for branch exceeds limit (-2048,2047) for label '".$spec[2]."' @ ".$spec[3]."\n"; }
    
    $Iwords[$spec[1] + 0] |= (($val & 0xFFF) << 15);
  }
  elsif (($spec[0] eq 'jmp') || ($spec[0] eq 'call'))
  {
    $label_addr =~ s/,.*//;
    $val = $label_addr;
    
    $Iwords[$spec[1] + 0] |= ($val & 0x00FFFFFF);
  }
  elsif ($spec[0] eq 'imm24')
  {
    $label_addr =~ s/,.*//;
    $val = $label_addr;
    
    $Iwords[$spec[1] + 0] |= ($val & 0x00FFFFFF);
  }
  elsif ($spec[0] eq 'imm32')
  {
    $label_addr =~ s/,.*//;
    $val = $label_addr;
    
    if (($Iwords[$spec[1] + 0] & 0xF0000000) == 0xE0000000)
    { $Iwords[$spec[1] + 0] |= (($val >> 4) & 0x0FFFFFFF); }
    else
    { die "ERROR: Immediate fixup prefix error for label '".$spec[2]."' @ ".$spec[3]."\n"; }
    
    if (($Iwords[$spec[1] + 1] & 0xC0000000) == 0x00000000)
    {
      if (($Iwords[$spec[1] + 1] & (1 << 14)) && ($Iwords[$spec[1] + 1] & (1 << 29)))
      { die "ERROR: Immediate fixup series instruction error for label '".$spec[2]."' @ ".$spec[3]."\n"; }
    }
    
    if ($Iwords[$spec[1] + 1] & (1 << 14))
    { 
      $Iwords[$spec[1] + 0] |= (($val & 7) << 3);
      $Iwords[$spec[1] + 0] |= ((($val >> 3) & 1) << 13);
    }
    elsif (($Iwords[$spec[1] + 1] & (1 << 29)) && (($Iwords[$spec[1] + 1] & 0xC0000000) == 0x00000000))
    {
      $Iwords[$spec[1] + 0] |= (($val & 7) << 18);
      $Iwords[$spec[1] + 0] |= ((($val >> 3) & 1) << 28);
    }
    else
    { die "ERROR: Immediate fixup format error for label '".$spec[2]."' @ ".$spec[3]."\n"; }
  }
  else
  { die "ERROR: Bad FixUp specification '$FixUp'... how did that happen???\n"; }
}

open(_IROM_FILE_, ">irom.hex") || die "ERROR: Unable to open 'irom.hex' for writing.\n";
open(_DRAM_FILE_, ">dram.hex") || die "ERROR: Unable to open 'dram.hex' for writing.\n";

foreach $line (@Iwords)
{
  printf _IROM_FILE_ "%08X\n", $line;
}

foreach $line (@Dwords)
{
  printf _DRAM_FILE_ "%08X\n", $line;
}

close(_IROM_FILE_);
close(_DRAM_FILE_);
exit;

#
# Command functions
#

sub cond_code
{
  my $code = shift(@_);
  my $rtn = 0;
  
  if ($code =~ /^\!/)
  { 
    $rtn |= 0x8;
    $code =~ s/\!//;
  }
  
  if ($code eq 'zero')
  { $rtn |= 0x0; }
  elsif ($code eq 'negative')
  { $rtn |= 0x1; }
  elsif ($code eq 'signed_overflow')
  { $rtn |= 0x2; }
  elsif ($code eq 'unsigned_overflow')
  { $rtn |= 0x3; }
  else
  { die "ERROR: Invalid condition code '$code' @ $input_filename:$linenum\n"; }
  
  return $rtn;
}

sub parse_num
{
  my $num = shift(@_);
  my $rtn = 0;
  my $neg = 0;
  
  if ($num =~ /^\s*\-/)
  {
    $neg = 1;
    $num =~ s/^\s*\-//;
  }
  
  if ($num =~ /^\s*0[Xx][0-9a-fA-F]+\s*/)
  { $rtn = oct($num); }
  elsif ($num =~ /^\s*0[0-7]+\s*/)
  { $rtn = oct($num); }
  elsif ($num =~ /^\s*[1-9][0-9]*\s*/)
  { $rtn = int($num); }
  else
  { die "ERROR: Invalid number '$num' @ $input_filename:$linenum\n"; }
  
  if ($neg)
  { $rtn = -($rtn); }
  
  return $rtn;
}

sub ldst
{
  my $cmd = shift(@_);
  my $args = shift(@_);
  my $rtn = 0;
  my $type;
  my $reg;
  my $ptr;
  my $offset;
  
  #print "ldst: $cmd ($args)\n";
  
  if (($cmd eq 'push') || ($cmd eq 'pop'))
  {
    if ($args =~ /[rR](\d+)/)
    {
      $type = 'w';
      $reg = $1;
      $ptr = 7;
      
      if ($cmd eq 'push')
      { $offset = 0x3F; }
      else
      { $offset = 1; }
    }
    else
    { die "ERROR: Push/Pop syntax error @ $input_filename:$linenum\n"; }
    
    $rtn |= (1 << 13);
  }
  elsif ($args =~ /(b|h|w)\s*,\s*[rR](\d+)\s*,\s*[rR](\d+)\[(\d\w*)\]/)
  {
    $type = $1;
    $reg = $2;
    $ptr = $3;
    $offset = parse_num($4);
    
    if (($reg < 0) || ($reg > 7))
    { die "ERROR: Register ($reg) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    if (($ptr < 0) || ($ptr > 7))
    { die "ERROR: Pointer ($ptr) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    if ($type eq 'w')
    {
      if (($offset < 0) || ($offset > 63))
      { die "ERROR: Word Offset ($offset) must be 0-63 @ $input_filename:$linenum\n"; }
    }
    else
    {
      if (($offset < 0) || ($offset > 31))
      { die "ERROR: Offset ($offset) must be 0-31 @ $input_filename:$linenum\n"; }
    }
  }
  elsif ($args =~ /(b|h|w)\s*,\s*[rR](\d+)\s*,\s*[rR](\d+)(\+\+|\-\-)(\d\w*)/)
  {
    $type = $1;
    $reg = $2;
    $ptr = $3;
    $inc_dec = $4;
    $offset = $5;
    
    if ($inc_dec eq '--')
    { $offset = -($offset); }
    
    if (($reg < 0) || ($reg > 7))
    { die "ERROR: Register ($reg) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    if (($ptr < 0) || ($ptr > 7))
    { die "ERROR: Pointer ($ptr) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    if ($type eq 'w')
    {
      if (($offset < -32) || ($offset > 31))
      { die "ERROR: Word Offset ($offset) must be -32,31 @ $input_filename:$linenum\n"; }
      
      $offset &= 0x3F;
    }
    else
    {
      if (($offset < -16) || ($offset > 15))
      { die "ERROR: Offset ($offset) must be -16,15 @ $input_filename:$linenum\n"; }
    
      $offset &= 0x1F;
    }
    
    $rtn |= (1 << 13);
  }
  else
  { die "ERROR: Ld/St syntax error @ $input_filename:$linenum\n"; }
  
  if (($cmd eq 'st') || ($cmd eq 'push'))
  { $rtn |= (1 << 14); }
  
  if ($type eq 'h')
  { $rtn |= (1 << 11); }
  elsif ($type eq 'w')
  { $rtn |= (2 << 11); }
  elsif ($type ne 'b')
  { die "ERROR: Invaid Ld/St type '$type' @ $input_filename:$linenum\n"; }
  
  $rtn |= ($offset << 6);
  $rtn |= ($ptr << 3);
  $rtn |= ($reg << 0);
  
  return $rtn;
}

sub brrtn
{
  my $cmd = shift(@_);
  my $args = shift(@_);
  my $rtn = 0;
  
  #print "br: $cmd ($args)\n";
  
  if ($cmd eq 'br')
  {
    if ($args =~ /(\!?\w+)\s*,\s*(\w+)/)
    {
      push(@FixUps, "br.short|$PC|".$2."|$input_filename:$linenum");
      my $cond = &cond_code($1);
      
      $rtn = (1 << 12) | ($cond << 8);
    }
    elsif ($args =~ /(\w+)/)
    {
      push(@FixUps, "br.long|$PC|".$1."|$input_filename:$linenum");
      
      $rtn = 0;
    }
    else
    { die "ERROR: BR syntax error @ $input_filename:$linenum\n"; }    
  }
  elsif (($cmd eq 'rtn') && ($args eq ''))
  {
    $rtn = (1 << 12) | (1 << 0);
  }
  elsif (($cmd eq 'icall') && ($args =~ /[rR]6/))
  {
    $rtn = (1 << 12);
  }
  else
  { die "ERROR: BR syntax error @ $input_filename:$linenum\n"; }
  
  return $rtn;
}

sub au
{
  my $cmd = shift(@_);
  my $args = shift(@_);
  my $rtn = 0;
  
  #print "au: $cmd ($args)\n";
  
  if (($cmd eq 'nop') && ($args eq ''))
  { return $rtn; }
  
  if (($cmd eq 'inc') || ($cmd eq 'dec') || ($cmd eq 'lsl') || ($cmd eq 'lsr') || ($cmd eq 'asr') || ($cmd eq 'sx'))
  {
    if ($args =~ /[rR](\d+)\s*,\s*(\d\w*)/)
    {
      my $rega = $1;
      my $imm = parse_num($2);
      
      if (($rega < 0) || ($rega > 7))
      { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; }
      
      if (($imm < 1) || ($imm > 8))
      { die "ERROR: Imm ($2) must be 1-8 @ $input_filename:$linenum\n"; }
      
      $rtn |= ($rega << 6) | (($imm - 1) << 3) | ($rega);  
    }
    elsif ($args =~ /[rR](\d+)\s*,\s*[rR](\d+)\s*,\s*(\d\w*)/)
    {
      my $rega = $2;
      my $regc = $1;
      my $imm = parse_num($3);
      
      if (($rega < 0) || ($rega > 7))
      { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; }
      
      if (($regc < 0) || ($regc > 7))
      { die "ERROR: Register C ($regc) must be r0-r7 @ $input_filename:$linenum\n"; }
      
      if (($imm < 1) || ($imm > 8))
      { die "ERROR: Imm ($imm) must be 1-8 @ $input_filename:$linenum\n"; }
      
      $rtn |= ($rega << 6) | (($imm - 1) << 3) | ($regc);  
    }
    else    
    { die "ERROR: '$cmd($args)' syntax error @ $input_filename:$linenum\n"; }   
  }
  elsif ($args =~ /[rR](\d+)\s*,\s*[rR](\d+)\s*,\s*[rR](\d+)/)
  {
    my $rega = $2;
    my $regb = $3;
    my $regc = $1;
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
    if (($regb < 0) || ($regb > 7))
    { die "ERROR: Register B ($regb) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
    if (($regc < 0) || ($regc > 7))
    { die "ERROR: Register C ($regc) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
    $rtn |= ($rega << 6) | ($regb << 3) | ($regc);  
  }
  elsif ($args =~ /[rR](\d+)\s*,\s*[rR](\d+)\s*,\s*(\-?\d\w*)/)
  {
    my $rega = $2;
    my $regc = $1;
    my $imm = parse_num($3);
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    if (($regc < 0) || ($regc > 7))
    { die "ERROR: Register C ($regc) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    $Iwords[$PC] = (0xE0000000) | (($imm >> 4) & 0x0FFFFFFF);
    $PC++;
    $rtn |= (1 << 14) | ((($imm >> 3) & 1) << 13) | ($rega << 6) | (($imm & 7) << 3) | ($regc);
  }
  elsif ($args =~ /[rR](\d+)\s*,\s*[rR](\d+)\s*,\s*(\w*)/)
  {
    my $rega = $2;
    my $regc = $1;
    push(@FixUps, "imm32|$PC|".$3."|$input_filename:$linenum");
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    if (($regc < 0) || ($regc > 7))
    { die "ERROR: Register C ($regc) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    $Iwords[$PC] = (0xE0000000);
    $PC++;
    $rtn |= (1 << 14) | ($rega << 6) | ($regc);
  }
  elsif ($args =~ /[rR](\d+)\s*,\s*[rR](\d+)/)
  {
    my $rega = $1;
    my $regb = $2;
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
    if (($regb < 0) || ($regb > 7))
    { die "ERROR: Register B ($regb) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
    $rtn |= ($rega << 6) | ($regb << 3) | ($rega);  
  }
  elsif ($args =~ /[rR](\d+)\s*,\s*(\-?\d\w*)/)
  {
    my $rega = $1;
    my $imm = parse_num($2);
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    $Iwords[$PC] = (0xE0000000) | (($imm >> 4) & 0x0FFFFFFF);
    $PC++;
    $rtn |= (1 << 14) | ((($imm >> 3) & 1) << 13) | ($rega << 6) | (($imm & 7) << 3) | ($rega);
  }
  elsif ($args =~ /[rR](\d+)\s*,\s*(\w*)/)
  {
    my $rega = $1;
    push(@FixUps, "imm32|$PC|".$2."|$input_filename:$linenum");
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; }
    
    $Iwords[$PC] = (0xE0000000);
    $PC++;
    $rtn |= (1 << 14) | ($rega << 6) | ($rega);
  }
  elsif ($args =~ /[rR](\d+)/)
  {
    my $rega = $1;
    
    if (($rega < 0) || ($rega > 7))
    { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
    $rtn |= ($rega << 6) | ($rega << 3) | ($rega);  
  }
  else
  { die "ERROR: AU '$cmd($args)' syntax error @ $input_filename:$linenum\n"; }
  
  if ($cmd eq 'mv')     { $rtn |= (0x00 << 9); }
  elsif ($cmd eq 'inv') { $rtn |= (0x01 << 9); }
  elsif ($cmd eq 'dec') { $rtn |= (0x02 << 9); }
  elsif ($cmd eq 'inc') { $rtn |= (0x03 << 9); }
  elsif ($cmd eq 'lsl') { $rtn |= (0x04 << 9); }
  elsif ($cmd eq 'lsr') { $rtn |= (0x05 << 9); }
  elsif ($cmd eq 'asr') { $rtn |= (0x06 << 9); }
  elsif ($cmd eq 'sx')  { $rtn |= (0x07 << 9); }
  elsif ($cmd eq 'cmp') { $rtn |= (0x08 << 9); }
  elsif ($cmd eq 'add') { $rtn |= (0x09 << 9); }
  elsif ($cmd eq 'sub') { $rtn |= (0x0A << 9); }
  elsif ($cmd eq 'and') { $rtn |= (0x0B << 9); }
  elsif ($cmd eq 'or')  { $rtn |= (0x0C << 9); }
  elsif ($cmd eq 'xor') { $rtn |= (0x0D << 9); }
  elsif ($cmd eq 'clr') { $rtn |= (0x0D << 9); } # alias of XOR, but assuming all three registers are the same
  else
  { die "ERROR: Invalid AU command '$cmd' @ $input_filename:$linenum\n"; }
  
  return $rtn;
}

sub calljmp
{
  my $cmd = shift(@_);
  my $args = shift(@_);
  my $rtn = 0;
  
  #print "calljmp: $cmd ($args)\n";
  
  if ($cmd eq 'call')
  {
    if ($args =~ /(\w+)/)
    {
      push(@FixUps, "call|$PC|".$1."|$input_filename:$linenum");
           
      $rtn = 0xFD000000;
    }
    else
    { die "ERROR: CALL syntax error @ $input_filename:$linenum\n"; }
  }
  elsif ($cmd eq 'jmp')
  {
    if ($args =~ /(\w+)/)
    {
      push(@FixUps, "jmp|$PC|".$1."|$input_filename:$linenum");
           
      $rtn = 0xFC000000;
    }
    else
    { die "ERROR: JMP syntax error @ $input_filename:$linenum\n"; }
  }
  else
  { die "ERROR: CALL/JMP/RTN syntax error @ $input_filename:$linenum\n"; }
  
  return $rtn;
}
   
sub ldi
{
  my $cmd = shift(@_);
  my $args = shift(@_);
  my $rtn = 0;
  
  #print "ldi: $cmd ($args)\n";
  
  if ($cmd eq 'ldi')
  {
    if ($args =~ /[rR](\d+)\s*,\s*(\-?\d\w*)/)
    {
      my $rega = $1;
      my $imm = parse_num($2);
           
      if (($rega < 0) || ($rega > 7))
      { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; } 
    
      $rtn = 0xF0000000 | ($rega << 24) | ($imm & 0x00FFFFFF);
    }
    elsif ($args =~ /[rR](\d+)\s*,(\w+)/)
    {
      my $rega = $1;
      push(@FixUps, "imm24|$PC|".$2."|$input_filename:$linenum");
           
      if (($rega < 0) || ($rega > 7))
      { die "ERROR: Register A ($rega) must be r0-r7 @ $input_filename:$linenum\n"; } 
           
      $rtn = 0xF0000000 | ($rega << 24);
    }
    else
    { die "ERROR: LDI syntax error @ $input_filename:$linenum\n"; }
  }
  else
  { die "ERROR: LDI syntax error @ $input_filename:$linenum\n"; }
  
  return $rtn;
}
