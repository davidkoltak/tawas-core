#!/usr/bin/python

#
# Tawas Linker: A very basic link for the 'tawas' processor core
#
# by David M. Koltak  06/02/2017
#
# The MIT License (MIT)
# 
# Copyright (c) 2017 David M. Koltak
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# 

import sys

def print_help():
  print("\nUSAGE: %s [-Ioutput] [-Doutput] {input} ..." % (sys.argv[0]))
  print("  -I   output 32-bit hex file for instruction segment")
  print("  -D   output 32-bit hex file for data segment\n")
  print("  -v   verbose output")
  print("  -V   version output")
  print("  -h   this message")
  exit(-1)


if len(sys.argv) < 2:
  print_help()
  
#
# Parse argv
#

verbose = 0
infiles = []
irom_out = ''
dram_out = ''

for arg in sys.argv[1:]:
  if arg[0:2] == '-I':
    irom_out = arg[2:]
  elif arg[0:2] == '-D':
    dram_out = arg[2:]
  elif arg == '-v':
    verbose = 1
  elif arg == '-V':
    print("VERSION: 0.1 (ALPHA)")
    exit(-1)
  elif arg[0:2] == '-h':
    print_help()
  else:
    infiles.append(arg)
    
if len(infiles) == 0:
  print("ERROR: No input files specified")
  exit(-1)

if irom_out == '':
  if infiles[0].endswith('.to'):
    irom_out = infiles[0]
    irom_out = obj_out[:-2] + 'is'
  elif infiles[0].endswith('.o'):
    irom_out = infiles[0]
    irom_out = obj_out[:-1] + 'is'
  else:
    irom_out = 'irom.hex'

if dram_out == '':
  if infiles[0].endswith('.to'):
    dram_out = infiles[0]
    dram_out = obj_out[:-2] + 'ds'
  elif infiles[0].endswith('.o'):
    dram_out = infiles[0]
    dram_out = obj_out[:-1] + 'ds'
  else:
    dram_out = 'dram.hex'
        
#
# Initialize database scructures
#   NOTE: Program segment is initialized with 4 x jumps to entry points
#

plabels = {}
pc = 4
prog = [0xf8000000, 0xf8000000, 0xf8000000, 0xf8000000]
pfixup = ['0:jump:_t0_reset:builtin:0', '1:jump:_t1_reset:builtin:0', 
          '2:jump:_t2_reset:builtin:0', '3:jump:_t3_reset:builtin:0']

dlabels = {}
dc = 0
data = []
dfixup = []

#
# Open each file and build database
#

for filename in infiles:
  try:
    fin = open(filename, "r")
  except IOError:
    print("ERROR: File '%s' not found" % filename)
    exit(-1)
  
  linenum = 0
  section = ''
  pc_start = pc
  dc_start = dc
  
  for line in fin:
    linenum += 1
    line = line.strip()
    if line == '':
      continue
    elif line[0] == '#':
      continue
    
    if line == '<program>':
      section = 'p'
    elif line == '<data>':
      section = 'd'
    elif line.find('=') >= 0:
      l = line.split('=')
      l[0] = l[0].strip()
      l[1] = l[1].strip()
      
      if l[0] in plabels:
        print("ERROR: Redefined program label '%s' @ %s:%d" % (l[0], filename, linenum))
        exit(-1)
        
      if l[0] in dlabels:
        print("ERROR: Redefined data label '%s' @ %s:%d" % (l[0], filename, linenum))
        exit(-1)
        
      try:
        offset = int(l[1], 0)
      except ValueError:
        print("ERROR: Invalid label offset '%s' @ %s:%d" % (l[1], filename, linenum))
        exit(-1)
      
      if section == 'p':
        plabels[l[0]] = pc_start + offset
      elif section == 'd':
        dlabels[l[0]] = dc_start + offset
    elif line[0] == ':':
      d = line.split(':')
      if len(d) == 3:
        if section == 'p':
          pfixup.append('%d:%s:%s:%s:%d' % (pc, d[1].strip(), d[2].strip(), filename, linenum));
        elif section == 'd':
          dfixup.append('%d:%s:%s:%s:%d' % (dc, d[1].strip(), d[2].strip(), filename, linenum));
      else:
        print("ERROR: Invalid fixup '%s' @ %s:%d" % (line, filename, linenum))
        exit(-1)
    else:
      d = line.split(':')
      
      try:
        n = int(d[0], 16)
      except ValueError:
        print("ERROR: Invalid data value '%s' @ %s:%d" % (line, filename, linenum))
        exit(-1)
      
      if len(d) == 3:
        if section == 'p':
          pfixup.append('%d:%s:%s:%s:%d' % (pc, d[1].strip(), d[2].strip(), filename, linenum));
        elif section == 'd':
          dfixup.append('%d:%s:%s:%s:%d' % (dc, d[1].strip(), d[2].strip(), filename, linenum));
          
      if section == 'p':
        prog.append(n)
        pc += 1
      elif section == 'd':
        data.append(n)
        dc += 4
        
  fin.close()

#
# Perform program segment fixups
#

for fixup in pfixup:
  f = fixup.split(':')
  addr = int(f[0])
  type = f[1]
  label = f[2]
  
  if label in plabels:
    label = plabels[label]
  elif label in dlabels:
    label = dlabels[label]
  else:
    print("ERROR: Unable to resolve label '%s' @ %s:%s" % (label, f[3], f[4]))
    exit(-1)
  
  if type == 'call':
    prog[addr] = (prog[addr] & 0xFF000000) | (label & 0x00FFFFFF)
    
  elif type == 'jump':
    prog[addr] = (prog[addr] & 0xFF000000) | (label & 0x00FFFFFF)
  
  elif type == 'br12.h':
    offset = label - addr
    if ((offset & 0xFFFFF000) != 0) and ((offset & 0xFFFFF000) != 0xFFFFF000):
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    prog[addr] == (prog[addr] & 0xFE007FFF) | ((offset << 15) & 0x01FF8000)
    
  elif type == 'br12.l':
    offset = label - addr
    if ((offset & 0xFFFFF000) != 0) and ((offset & 0xFFFFF000) != 0xFFFFF000):
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    prog[addr] == (prog[addr] & 0xFFFFF000) | ((offset << 0) & 0x00000FFF)
    
  elif type == 'br8.h':
    offset = label - addr
    if ((offset & 0xFFFFFF00) != 0) and ((offset & 0xFFFFFF00) != 0xFFFFFF00):
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    prog[addr] == (prog[addr] & 0xFFE07FFF) | ((offset << 15) & 0x001F8000)
  
  elif type == 'br8.l':
    offset = label - addr
    if ((offset & 0xFFFFFF00) != 0) and ((offset & 0xFFFFFF00) != 0xFFFFFF00):
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    prog[addr] == (prog[addr] & 0xFFFFFF00) | ((offset << 0) & 0x000000FF)
    
  elif type == 'imm32.h':
    prog[addr-1] = (prog[addr-1] & 0xF000000) | ((label >> 4) & 0x0FFFFFFF)
    prog[addr] = (prog[addr] & 0xFFE3FFFF) | ((label << 18) & 0x001C0000)
    prog[addr] = (prog[addr] & 0xEFFFFFFF) | ((label << 28) & 0x10000000)
    
  elif type == 'imm32.l':
    prog[addr-1] = (prog[addr-1] & 0xF000000) | ((label >> 4) & 0x0FFFFFFF)
    prog[addr] = (prog[addr] & 0xFFFFFFC7) | ((label << 3) & 0x00000038)
    prog[addr] = (prog[addr] & 0xEFFFDFFF) | ((label << 13) & 0x00002000)
    
  elif type == 'imm24':
    prog[addr] = (prog[addr] & 0xFF000000) | (label & 0x00FFFFFF)
    
  elif type == 'imm9.h':
    if (label & 0xFFFFFE00) != 0:
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    prog[addr] = (prog[addr] & 0xF803FFFF) | ((label << 18) & 0x07FC0000)
    
  elif type == 'imm9.l':
    if (label & 0xFFFFFE00) != 0:
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    prog[addr] = (prog[addr] & 0xFFFFF007) | ((label << 3) & 0x00000FF8)
    
  else:
    print("ERROR: Invalid fixup type @ %s:%s" % (f[3], f[4]))
    exit(-1)

#
# Perform data segment fixups
#

for fixup in dfixup:
  f = fixup.split(':')
  addr = int(f[0])
  type = f[1]
  label = f[2]
  
  if label in plabels:
    label = plabels[label]
  elif label in dlabels:
    label = dlabels[label]
  else:
    print("ERROR: Unable to resolve label '%s' @ %s:%s" % (label, f[3], f[4]))
    exit(-1)
  
  if type == 'ptr32':
    data[addr >> 2] = label
  elif type == 'ptr16.h':
    if (label & 0xFFFF0000) != 0:
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    data[addr >> 2] = (data[addr >> 2] & 0x0000FFFF) | ((label << 16) & 0xFFFF0000)
  elif type == 'ptr16.l':
    if (label & 0xFFFF0000) != 0:
      print("ERROR: Fixup value overflow @ %s:%s" % (f[3], f[4]))
      exit(-1)
    data[addr >> 2] = (data[addr >> 2] & 0xFFFF0000) | ((label << 0) & 0xFFFFFFFF)
  else:
    print("ERROR: Invalid fixup type @ %s:%s" % (f[3], f[4]))
    exit(-1)
        
#
# Dump instruction/data segments to output files
#

try:
  fout = open(irom_out, "w")
except IOError:
    print("ERROR: Unable to create file '%s'" % filename)
    exit(-1)

for p in prog:
  fout.write("%08X\n" % (p))

fout.close()

try:
  fout = open(dram_out, "w")
except IOError:
    print("ERROR: Unable to create file '%s'" % filename)
    exit(-1)

for d in data:
  fout.write("%08X\n" % (d))

fout.close()

#
# Verbose output
#

if verbose != 0:
  print("\nProgram Labels:")
  for label in plabels:
    print("  %20s = %08x" % (label, plabels[label]))

  print("\nProgram Fixups:")
  for fixup in pfixup:
    print("  %s" % (fixup))

  print("\nData Labels:")
  for label in dlabels:
    print("  %20s = %08x" % (label, dlabels[label]))

  print("\nData Fixups:")
  for fixup in dfixup:
    print("  %s" % (fixup))
  
  print("\nWrote %d words of instructions to '%s'" % (len(prog), irom_out))
  print("\nWrote %d bytes of data to '%s'" % (len(data) * 4, dram_out))
  print("")
  
exit(0)
