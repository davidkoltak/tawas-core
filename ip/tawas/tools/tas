#!/usr/bin/python

#
# Tawas Assembler: A very basic assembler for the 'tawas' processor core
#
# by David M. Koltak  06/02/2017
#
# The MIT License (MIT)
# 
# Copyright (c) 2017 David M. Koltak
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# 

import sys

def print_help():
  print("\nUSAGE: %s [-Ooutput] {input} ..." % (sys.argv[0]))
  print("  -O   output object file")
  print("  -v   verbose output")
  print("  -V   version output")
  print("  -h   this message")
  exit(-1)


if len(sys.argv) < 2:
  print_help()
  
#
# Parse argv
#

verbose = 0
infiles = []
obj_out = ''
dram_out = 'dram.hex'

for arg in sys.argv[1:]:
  if arg[0:2] == '-O':
    obj_out = arg[2:]
  elif arg == '-v':
    verbose = 1
  elif arg == '-V':
    print("VERSION: 0.1 (ALPHA)")
    exit(-1)
  elif arg[0:2] == '-h':
    print_help()
  else:
    infiles.append(arg)

if len(infiles) == 0:
  print("ERROR: No input files specified")
  exit(-1)
  
if obj_out == '':
  if infiles[0].endswith('.as'):
    obj_out = infiles[0]
    obj_out = obj_out[:-2] + 'to'
  elif infiles[0].endswith('.a'):
    obj_out = infiles[0]
    obj_out = obj_out[:-1] + 'to'
  else:
    obj_out = 'a.to'
   
#
# Initialize database scructures
#

plabels = {}
pc = 0
prog = []
pfixup = []

dlabels = {}
dc = 0
data = []
dfixup = []

#
# Open each file and build database
#

for filename in infiles:
  try:
    fin = open(filename, "r")
  except IOError:
    print("ERROR: File '%s' not found" % filename)
    exit(-1)
  
  linenum = 0
  
  for line in fin:
    linenum += 1
    line = line.strip()
    if line == '':
      continue
    if line[0] == '#':
      continue
    
    if line[-1] == ':':
      plabels[line[:-1]] = pc
      continue
      
    if line[0] == '.':
      dctv = line.split()
      if dctv[0] == '.alloc':
        if len(dctv) != 4:
          print("ERROR: Wrong number of arguments for directive '%s' @ %s:%d" % (line, filename, linenum))
          exit(-1)
          
        try:
          cnt = int(dctv[3], 0)
        except ValueError:
          print("ERROR: Alloc count field is not a number '%s' @ %s:%d" % (line, filename, linenum))
          exit(-1)
          
        if dctv[2] == 'word':
          if dc & 3:
            dc = (dc & 0xFFFFFFFC) + 4
          dlabels[dctv[1]] = dc
          for x in range(cnt):
            data.append(0)
            dc += 4
        elif dctv[2] == 'half':
          if dc & 1:
            dc = (dc & 0xFFFFFFFE) + 2
          dlabels[dctv[1]] = dc
          for x in range(cnt):
            if (dc & 2) == 0:
              data.append(0)
            else:
              data[dc >> 2] = (data[dc >> 2] & 0x0000FFFF)
            dc += 2
        elif dctv[2] == 'byte':
          dlabels[dctv[1]] = dc
          for x in range(cnt):
            if (dc & 3) == 0:
              data.append(0)
            elif (dc & 3) == 1:
              data[dc >> 2] = (data[dc >> 2] & 0xFFFF00FF)
            elif (dc & 3) == 2:
              data[dc >> 2] = (data[dc >> 2] & 0xFF00FFFF)
            else:
              data[dc >> 2] = (data[dc >> 2] & 0x00FFFFFF)
            dc += 1          
        else:
          print("ERROR: Invalid alloc data type '%s' @ %s:%d" % (dctv[1], filename, linenum))
          exit(-1)
          
      elif dctv[0] == '.data':
        if len(dctv) < 4:
          print("ERROR: Wrong number of arguments for directive '%s' @ %s:%d" % (line, filename, linenum))
          exit(-1)
        
        if dctv[2] == 'word':
          if dc & 3:
            dc = (dc & 0xFFFFFFFC) + 4
          dlabels[dctv[1]] = dc
          for x in dctv[3:]:
            try:
              value = int(x, 0)
              data.append(value)
            except ValueError:
              data.append(0)
              dfixup.append("%d:ptr32:%s" % (dc, x))
            dc += 4
        elif dctv[2] == 'half':
          if dc & 1:
            dc = (dc & 0xFFFFFFFE) + 2
          dlabels[dctv[1]] = dc
          for x in dctv[3:]:
            try:
              value = int(x, 0)
              if (dc & 2) == 0:
                data.append(value & 0xFFFF)
              else:
                data[dc >> 2] = (data[dc >> 2] & 0x0000FFFF) | ((value << 16) & 0xFFFF0000)
            except ValueError:
              if (dc & 2) == 0:
                data.append(0)
                dfixup.append("%d:ptr16.l:%s" % (dc, x))
              else:
                data[dc >> 2] = (data[dc >> 2] & 0x0000FFFF)
                dfixup.append("%d:ptr16.h:%s" % (dc, x))
            dc += 2
        elif dctv[2] == 'byte':
          dlabels[dctv[1]] = dc
          for x in dctv[3:]:
            try:
              value = int(x, 0)
            except ValueError:
              print("ERROR: Alloc value field is not a number '%s' @ %s:%d" % (line, filename, linenum))
              exit(-1)
            if (dc & 3) == 0:
              data.append(value & 0x000000FF)
            elif (dc & 3) == 1:
              data[dc >> 2] = (data[dc >> 2] & 0xFFFF00FF) | ((value << 8) & 0x0000FF00)
            elif (dc & 3) == 2:
              data[dc >> 2] = (data[dc >> 2] & 0xFF00FFFF) | ((value << 16) & 0x00FF0000)
            else:
              data[dc >> 2] = (data[dc >> 2] & 0x00FFFFFF) | ((value << 24) & 0xFF000000)
            dc += 1          
        else:
          print("ERROR: Invalid alloc data type '%s' @ %s:%d" % (dctv[1], filename, linenum))
          exit(-1)
      
      elif dctv[0] == '.string':
        if len(dctv) < 3:
          print("ERROR: Wrong number of arguments for directive '%s' @ %s:%d" % (line, filename, linenum))
          exit(-1)
      
        s = line.replace('.string', '', 1)
        s = s.replace(dctv[1], '', 1)
        s = s.strip()
        if s[0] == "'":
          s = s.strip("'")
        if s[0] == '"':
          s = s.strip('"')
          
        dlabels[dctv[1]] = dc
        for x in s:
          value = ord(x)
          if (dc & 3) == 0:
            data.append(value & 0x000000FF)
          elif (dc & 3) == 1:
            data[dc >> 2] = (data[dc >> 2] & 0xFFFF00FF) | ((value << 8) & 0x0000FF00)
          elif (dc & 3) == 2:
            data[dc >> 2] = (data[dc >> 2] & 0xFF00FFFF) | ((value << 16) & 0x00FF0000)
          else:
            data[dc >> 2] = (data[dc >> 2] & 0x00FFFFFF) | ((value << 24) & 0xFF000000)
          dc += 1    
            
        if (dc & 3) == 0:
          data.append(0)
        elif (dc & 3) == 1:
          data[dc >> 2] = (data[dc >> 2] & 0xFFFF00FF)
        elif (dc & 3) == 2:
          data[dc >> 2] = (data[dc >> 2] & 0xFF00FFFF)
        else:
          data[dc >> 2] = (data[dc >> 2] & 0x00FFFFFF)
        dc += 1  
          
      else:
        print("ERROR: Invalid directive '%s' @ %s:%d" % (line, filename, linenum))
        exit(-1)
      continue
      
    if line[0] == '\\':
      prog[-1].append(line[1:].strip())
    else:
      prog.append([line])
      pc += 1
    
  fin.close()

#
# Verbose output
#

if verbose != 0:
  print("\nProgram Labels:")
  for label in plabels:
    print("  %20s = %08x" % (label, plabels[label]))
    
  print("\nProgram Fixups:")
  for fixup in pfixup:
    print("  %s" % (fixup))

  print("\nData Labels:")
  for label in dlabels:
    print("  %20s = %08x" % (label, dlabels[label]))

  print("\nData Fixups:")
  for fixup in dfixup:
    print("  %s" % (fixup))
  
  print("\nProgram:")
  for p in prog:
    print("  %s" % (p))
    
  print("\nData:")
  for d in data:
    print("  %08X" % (d))
    
  print("")

exit(0)
